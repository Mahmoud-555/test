/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('myproject:server');
var http = require('http');
const socketIo = require('socket.io');
const mongoose = require('mongoose');
const jwt = require('jsonwebtoken');
const User = require('../models/userModel');
const Notifications = require('../models/notificationModel');
const Quiz = require('../models/quizModel');
/**
 * Get port from environment and store in Express.
 */
var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);
/**
 * Create HTTP server.
 */
var server = http.createServer(app);
const io = socketIo(server);
app.io = io
// sssssssssssss

// online user
const onlineUsers = {};
app.onlineUsers = onlineUsers

// active quizes
const activeCompetitions = {};



// دالة للعثور على الأصدقاء المتصلين
const getOnlineFriends = (friends) => {
  return friends.filter(friend => onlineUsers[friend._id]);
};
// Function to sort users by score (and alphabetically if scores are tied)
function sortUsersByScore(users) {
  return users.sort((a, b) => {
    if (b.score === a.score) {
      return a.username.localeCompare(b.username); // Alphabetical order in case of ties
    }
    return b.score - a.score; // Sort by score, descending
  });
}

const sendQuestion = (Id) => {

  let competition = activeCompetitions[Id]
  console.log("index", competition.currentIndex)
  // get current question
  let question = competition.questions[competition.currentIndex]
  activeCompetitions[Id].questionStartedAt = Date.now()

  io.to(`${Id}/participants`).emit("newQuestion", question, question.duration, competition.currentIndex + 1, competition.questions.length)

  let duration = question.duration || 5

  if (competition.currentIndex >= competition.questions.length - 1) {
    // final 
    console.log("last question")
    // wait to question end
    setTimeout(() => {
      competition.rank = sortUsersByScore(competition.rank)

      io.to(`${Id}/participants`).emit("updateScore", competition.rank)

      for (let index = 0; index < competition.participants.length; index++) {
        const participant = competition.participants[index];
        let currentQuestion = { "_id": question._id, "question": question.question, "answers": question.answers, "correct": question.correct, "images": question.images, }
        if (activeCompetitions[Id].usersAnswers[participant][competition.currentIndex]) {
          currentQuestion.userAnswer = activeCompetitions[Id].usersAnswers[participant][competition.currentIndex]
          console.log(currentQuestion)

        }
        io.to(participant.toString()).emit("questionResult", currentQuestion)
      }

      setTimeout(async () => {
        // activeCompetitions[Id].currentIndex++
        // save 
        competition.status = "inactive"
        updated = await Quiz.findByIdAndUpdate(Id, competition, { new: true })
        console.log("updated")

        delete activeCompetitions[Id]


      }, 3000);

    }, duration * 1000);
  } else {
    setTimeout(async () => {
      competition.rank = sortUsersByScore(competition.rank)
      updated = await Quiz.findByIdAndUpdate(Id, competition, { new: true })
      console.log("updated")
      io.to(`${Id}/participants`).emit("updateScore", competition.rank)

      for (let index = 0; index < competition.participants.length; index++) {
        const participant = competition.participants[index];
        let currentQuestion = { "_id": question._id, "question": question.question, "answers": question.answers, "correct": question.correct, "images": question.images, }
        if (activeCompetitions[Id].usersAnswers[participant][competition.currentIndex]) {
          currentQuestion.userAnswer = activeCompetitions[Id].usersAnswers[participant][competition.currentIndex]
          console.log(currentQuestion)

        }
        io.to(participant.toString()).emit("questionResult", currentQuestion)
      }

      setTimeout(() => {
        activeCompetitions[Id].currentIndex++
        sendQuestion(Id)
      }, 5000);


    }, duration * 1000);
  }



};

io.on('connection', async (socket) => {
  console.log("connected")

  const cookieHeader = socket.request.headers.cookie;
  // Initialize an empty object for parsed cookies
  let parsedCookies = {};
  // If cookie header exists, parse it
  if (cookieHeader) {
    // Split the cookies string and iterate through it to create an object
    cookieHeader.split(';').forEach(cookie => {
      const parts = cookie.split('=');
      parsedCookies[parts[0].trim()] = decodeURIComponent(parts[1] || '');
    });
  }

  // Retrieve the token
  const token = await parsedCookies['token']; // The name of your cookie is "token"

  // Optionally: Verify the token
  if (token) {
    const decoded = jwt.verify(token, process.env.JWT_SECRET_KEY);

    socket.userData = await User.findById(decoded.userId).populate("friends", ["username", "profileImage"])

    socket.join(socket.userData._id.toString());
    if (!onlineUsers[socket.userData._id.toString()]) {
      onlineUsers[socket.userData._id.toString()] = true
      // online friends
      const onlineFriends = await getOnlineFriends(socket.userData.friends);

      onlineFriends.forEach(friend => {



        // إذا كان الصديق متصل، أرسل له إشعار قطع الاتصال
        io.to(friend._id.toString()).emit('friendStatusUpdate', { _id: socket.userData._id, username: socket.userData.username, profileImage: socket.userData.profileImage }, 'connected');
      })

    }






  } else {
    console.log("no token")
    return socket.disconnect(); // Disconnect if no token found

  }

  socket.on('getOnlineFriends', async () => {
    console.log("get")
    try {
      let onlineFriends = await getOnlineFriends(socket.userData.friends);
      socket.emit('updateFriendList', onlineFriends);
    } catch (error) {
      console.error("Error getting online friends: ", error);
    }
  });

  socket.on('addFriend', async (friendUsername) => {
    const user = await User.findOne({ username: socket.handshake.query.username });

    if (user && !user.friends.includes(friendUsername)) {
      user.friends.push(friendUsername);
      await user.save();
      // أرسل إشعارًا فقط للمستخدم الذي أضاف صديقًا
      socket.emit('friendAdded', friendUsername);
    }
  });

  socket.on('removeFriend', async (friendUsername) => {
    const user = await User.findOne({ username: socket.handshake.query.username });

    if (user) {
      user.friends = user.friends.filter(friend => friend !== friendUsername);
      await user.save();
      socket.emit('friendRemoved', friendUsername);
    }
  });
  socket.on("inviteUsers", async (invitedUsers) => {
    const challenge = await Quiz.findOne({ creator: socket.userData._id, status: "active", type: "challenge" }).sort({ createdAt: -1 }).populate("questions");

    if (challenge) {
      // add to active competitions
      activeCompetitions[challenge._id] = challenge


      const message = `<strong>${socket.userData.username}</strong> invited you to a challenge`
      const link = `/challenge/${challenge._id}`
      // check existance of notification
      const n = await Notifications.findOne({ href: link });
      if (!n) {
        // invite users
        invitedUsers.forEach(async (username) => {

          const user = await User.findOne({ username: username });
          if (user) {
            const newNotification = new Notifications({ user: user._id, message: message, avatar: socket.userData.profileImage, href: link, type: "invitation" })
            const notification = await newNotification.save()

            if (onlineUsers[user._id]) {

              io.to(user._id.toString()).emit("newNotification", { message: notification.message, avatar: notification.avatar, _id: notification._id, type: notification.type, href: notification.href })
            }




          }

        })
      }

    }





  })
  socket.on("start competition", async (data, callback) => {
    console.log(data)
    const competition = activeCompetitions[data.Id] || await Quiz.findOne({ _id: data.Id, creator: socket.userData._id, status: "active", type: "challenge" }).populate("questions");
    if (competition) {
      console.log(competition)
      const remain = 2
      const startAt = Date.now() + (remain * 1000)



      if (competition.creator.toString() == socket.userData._id) {
        if (!competition.startAt) {

          activeCompetitions[data.Id] = competition
          activeCompetitions[data.Id].startAt = startAt

          io.to(data.Id).emit("competitionStartAt", startAt)
          callback({
            status: "ok"
          })
          setTimeout(() => {
            activeCompetitions[data.Id].rank = sortUsersByScore(competition.rank)

            io.to(`${data.Id}/participants`).emit("updateScore", competition.rank)

            sendQuestion(data.Id)
          }, remain * 1000);



        }
      } else {
        console.log("you are not the owner")

      }








    }

  })


  // join competition room
  socket.on("ready", async (Id, callback) => {
    let competition = activeCompetitions[Id]
    if (competition) {

      if (!competition.startAt) {
        // didn't start yet
        socket.join(Id)
        io.to(competition.creator.toString()).emit("Ready user", { _id: socket.userData._id, username: socket.userData.username, profileImage: socket.userData.profileImage }, 'connected')
        callback({
          status: "ok"
        })
      } else {
        if (competition.startAt > Date.now()) {
          // will start soon
          socket.join(Id)
          io.to(competition.creator.toString()).emit("Ready user", { _id: socket.userData._id, username: socket.userData.username, profileImage: socket.userData.profileImage }, 'connected')
          socket.emit("competitionStartAt", competition.startAt)
          callback({
            status: "ok"
          })
        } else {
          // started
          // console.log("readyrank1", activeCompetitions[Id].rank)

          if (competition.participants.includes(socket.userData._id)) {
            let question = competition.questions[competition.currentIndex]
            let timeRemaining = Math.round(question.duration - (Date.now() - competition.questionStartedAt) / 1000)
            if (timeRemaining <= 0) {
              let currentQuestion = { "_id": question._id, "question": question.question, "answers": question.answers, "correct": question.correct, "images": question.images, }
              if (activeCompetitions[Id].usersAnswers[socket.userData._id][competition.currentIndex]) {
                currentQuestion.userAnswer = activeCompetitions[Id].usersAnswers[socket.userData._id][competition.currentIndex]
                // console.log(currentQuestion)

              }
              socket.emit("newQuestion", question, timeRemaining, competition.currentIndex + 1, competition.questions.length)
              socket.emit("questionResult", currentQuestion)

            } else {
              socket.emit("newQuestion", question, timeRemaining, competition.currentIndex + 1, competition.questions.length)

            }
            socket.emit("updateScore", competition.rank)

            socket.join(`${Id}/participants`)

            callback({
              status: "joined"



            })

          } else {
            callback({
              status: "join"
            })
          }





        }
      }



    } else {
      try {
        competition = await Quiz.findOne({ _id: Id, status: "active", type: "challenge" }).populate("questions");

        if (competition) {
          activeCompetitions[Id] = competition


          if (!competition.startAt) {
            // didn't start yet
            socket.join(Id)
            io.to(competition.creator.toString()).emit("Ready user", { _id: socket.userData._id, username: socket.userData.username, profileImage: socket.userData.profileImage }, 'connected')
            callback({
              status: "ok"
            })
          } else {
            if (competition.startAt > Date.now()) {
              // will start soon
              socket.join(Id)
              io.to(competition.creator.toString()).emit("Ready user", { _id: socket.userData._id, username: socket.userData.username, profileImage: socket.userData.profileImage }, 'connected')
              socket.emit("competitionStartAt", competition.startAt)
              callback({
                status: "ok"
              })
            } else {
              // started         
              callback({
                status: "join"
              })


            }
          }


        } else {
          console.log("competition not found")
        }
      } catch (error) {
        console.log(error)
      }


    }






  })

  socket.on("join competition", async (Id) => {
    if (Id) {
      const competition = activeCompetitions[Id] || await Quiz.findOne({ _id: Id, status: "active", type: "challenge" });
      // console.log("competition")
      if (competition) {


        if (!activeCompetitions[Id].rank.some(user => user._id === socket.userData._id)) {
          activeCompetitions[Id].participants.push(socket.userData._id)
          if (activeCompetitions[Id].userAnswers) {
            activeCompetitions[Id].userAnswers[socket.userData._id.toString()] = []
          } else {
            activeCompetitions[Id].userAnswers = {}
            activeCompetitions[Id].userAnswers[socket.userData._id.toString()] = []

          }

          // const exists = users.some(user => user.id === userToFind.id);
          activeCompetitions[Id].rank.push({ _id: socket.userData._id.toString(), username: socket.userData.username, avatar: socket.userData.profileImage, score: 0 })

        }


        if (!activeCompetitions[Id].usersAnswers[socket.userData._id]) {
          activeCompetitions[Id].usersAnswers[socket.userData._id] = []

        }

        socket.join(`${Id}/participants`)

        // send current question 
        if (competition.startAt < Date.now()) {
          let question = competition.questions[competition.currentIndex]
          competition.questionStartedAt
          let timeRemaining = Math.round(question.duration - (Date.now() - competition.questionStartedAt) / 1000)
          console.log("llll", timeRemaining)
          socket.emit("newQuestion", question, timeRemaining, competition.currentIndex + 1, competition.questions.length)

        }


      }
    } else {
      console.log("no id")
    }






  })

  socket.on("answer", async (Id, userAnswers, callback) => {
    console.log(userAnswers)

    try {

      if (activeCompetitions[Id]) {
        const user = activeCompetitions[Id].rank.find(user => user._id.toString() === socket.userData._id.toString());
        let score = user.score || 0;
        let currentQuestion = activeCompetitions[Id].questions[activeCompetitions[Id].currentIndex]
        // check if user answer current question
        if (userAnswers[currentQuestion._id]) {
          console.log("score before", score)

          // check existance of answer container
          if (!activeCompetitions[Id].usersAnswers[socket.userData._id]) {
            activeCompetitions[Id].usersAnswers[socket.userData._id] = []

          }

          // check if user didn't answer this question before
          if (!activeCompetitions[Id].usersAnswers[socket.userData._id][activeCompetitions[Id].currentIndex]) {
            // check if the answer is correct
            activeCompetitions[Id].usersAnswers[socket.userData._id][activeCompetitions[Id].currentIndex] = userAnswers[currentQuestion._id]
            if (currentQuestion.correct.includes(userAnswers[currentQuestion._id])) {
              score++
              user.score = score

            }

            console.log("score after", score)
          } else {
            console.log("there is an answer before")
          }

        } else {
          console.log("this is not current question")

        }

      } else {
        callback({
          status: "faild"
        })
      }

    } catch (error) {
      console.log(error)
    }



    callback({
      status: "ok"
    })
  })



  socket.on("disconnecting", () => {
    // console.log(io.sockets.adapter.rooms); // the Set contains at least the socket ID
    // console.log(io.sockets.adapter.rooms.get(socket.userData._id.toString())); // the Set contains at least the socket ID


  });

  // عند قطع الاتصال
  socket.on('disconnect', () => {
    console.log(io.sockets.adapter.rooms.get(socket.userData._id.toString())); // the Set contains at least the socket ID
    if (!io.sockets.adapter.rooms.get(socket.userData._id.toString())) {
      onlineUsers[socket.userData._id] = false;

      // مسح المستخدم المنقطع من الكائن
      socket.userData.friends.forEach(friend => {
        if (onlineUsers[friend._id]) {
          // إذا كان الصديق متصل، أرسل له إشعار قطع الاتصال
          io.to(friend._id.toString()).emit('friendStatusUpdate', socket.userData._id, 'disconnected');
        }

      });

    }





    // console.log('A user disconnected:', socket.userData._id);


  });


});


// ssssssssssssss




/**
 * Listen on provided port, on all network interfaces.
 */

// server.listen(port, "192.168.1.2");
// server.listen(port, "192.168.1.3");
// server.listen(port, "192.168.1.4");
// server.listen(port, "192.168.1.5");
// server.listen(port, "192.168.1.6");
// server.listen(port, "192.168.1.7");
// server.listen(port, "192.168.1.8");
// server.listen(port, "197.59.25.224");
server.listen(port);
server.listen(process.env.PORT || 10000, '0.0.0.0')
console.log("port",port);

server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + z
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
